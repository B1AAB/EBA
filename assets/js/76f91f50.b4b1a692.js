"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5021],{5187:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"contribute/design-decisions","title":"Design decisions","description":"Design decisions","source":"@site/docs/contribute/design-decisions.md","sourceDirName":"contribute","slug":"/contribute/design-decisions","permalink":"/docs/contribute/design-decisions","draft":false,"unlisted":false,"editUrl":"https://github.com/B1AAB/EBA/edit/main/website/docs/contribute/design-decisions.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"title":"Design decisions","description":"Design decisions","sidebar_position":0,"slug":"design-decisions"},"sidebar":"tutorialSidebar","previous":{"title":"Contributing","permalink":"/docs/contribute/overview"},"next":{"title":"Current limitations","permalink":"/docs/contribute/current-limitations"}}');var t=i(4848),o=i(8453);const r={title:"Design decisions",description:"Design decisions",sidebar_position:0,slug:"design-decisions"},a=void 0,c={},d=[{value:"Why Bitcoin Core?",id:"why-bitcoin-core",level:3},{value:"Why Neo4j and TSV?",id:"why-neo4j-and-tsv",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"why-bitcoin-core",children:"Why Bitcoin Core?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://bitcoin.org/en/bitcoin-core",children:"Bitcoin Core"}),"\nis one of the most commonly used, maintained, and supported\nopen-source clients for Bitcoin. Hence, it is an ideal option\nfor communicating with the Bitcoin network and localizing\nall the blocks.\nHowever, one can implement a specialized method to read block\ninformation from the localized data, which could outperform\nBitcoin Core's general-purpose methods.\nDespite this, we decided to use Bitcoin Core instead of\ndeveloping a specialized parser because it would have\nadded development complexity that is both beyond the\nscope of this work and highly error-prone, given the\nlong history of BIPs implemented since the genesis block.\nTherefore, we use Bitcoin Core's REST API to parse data\nfrom blocks. This enables us to remain focused on\ngenerating the graph from transaction data and rely\non Bitcoin Core to resolve the technical details of\nreading transactions."]}),"\n",(0,t.jsx)(n.h3,{id:"why-neo4j-and-tsv",children:"Why Neo4j and TSV?"}),"\n",(0,t.jsxs)(n.p,{children:["Our choice of data representation was driven by two key requirements:\n",(0,t.jsx)(n.strong,{children:"portability"})," for easy community sharing and ",(0,t.jsx)(n.strong,{children:"scalability"})," to handle a massive graph.\nAfter experimenting with several formats, we selected a combination of batched TSV\nfiles and the Neo4j graph database to achieve the right balance."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Batched TSV Files for Portability"}),"\nWhile a single, massive TSV file is impractical for this dataset,\nTSVs remain highly portable. To solve the scaling issue,\nwe adopted a batching strategy: we store different node and edge types\nin separate, homogeneous files and enforce a size limit on each.\nThis results in multiple, smaller batches of reasonably-sized\nfiles that are easy to share and use."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Neo4j for Scalable Queries"}),"\nGraph databases are purpose-built for the complex queries this dataset requires,\nsuch as efficiently retrieving ",(0,t.jsx)(n.em,{children:"n"}),"-hop neighbors of a given node.\nWe chose Neo4j specifically because of its wide adoption,\nand flexible licensing that offers both a free community edition\nand scalable production-grade solutions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Other Formats We Considered"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"https://numpy.org/doc/stable/reference/generated/numpy.memmap.html",children:"np.memmap"}),":"]}),"\nWe tested this disk-based binary format,\nwhich is designed to minimize RAM usage.\nWhile promising, it was too slow for the random-access queries\nrequired by our graph sampling algorithms\n(e.g., fetch neighbors of a given root at ",(0,t.jsx)(n.em,{children:"n"}),"-hop distance)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Relational Databases (e.g., PostgreSQL):"}),"\nRelational databases were efficient for indexed lookups\n(e.g., retrieving a script's details by its address);\nhowever, their performance degraded significantly on graph traversal\nqueries, which are generally implemented using nested INNER JOINs.\nSimilar to ",(0,t.jsx)(n.code,{children:"np.memmap"}),", this approach did not scale for sampling neighbors of\nhundreds of thousands of root nodes."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);